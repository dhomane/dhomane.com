"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePort = exports.isWindows = exports.getBin = exports.computeAppLocationFromArtifactLocation = exports.parseUrl = exports.validateDevServerConfig = exports.isPortAvailable = exports.isHttpUrl = exports.isAcceptingTcpConnections = exports.argv = exports.readConfigFile = exports.decodeCookie = exports.serializeCookie = exports.validateCookie = exports.response = void 0;
const child_process_1 = require("child_process");
const cookie_1 = __importDefault(require("cookie"));
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const path_1 = __importDefault(require("path"));
const yaml_1 = __importDefault(require("yaml"));
const config_1 = require("../config");
const runtimes_1 = require("./runtimes");
const response = ({ context, status, headers, cookies, body = "" }) => {
    if (typeof status !== "number") {
        throw Error("TypeError: status code must be a number.");
    }
    let location;
    if (headers) {
        ({ location } = headers);
        headers = {
            ...headers,
            location: process.env.DEBUG ? null : location,
        };
    }
    body = body || null;
    if (process.env.DEBUG) {
        body =
            body ||
                JSON.stringify({
                    location,
                    debug: {
                        response: {
                            cookies: {
                                ...cookies,
                            },
                            headers: {
                                ...headers,
                            },
                        },
                        context: {
                            ...context.bindingData,
                        },
                    },
                }, null, 2);
    }
    const res = {
        status,
        cookies,
        headers: {
            status,
            "Content-Type": "application/json",
            ...headers,
        },
        body,
    };
    return res;
};
exports.response = response;
const validateCookie = (cookieValue) => {
    if (typeof cookieValue !== "string") {
        throw Error(`TypeError: cookie value must be a string.`);
    }
    const cookies = cookie_1.default.parse(cookieValue);
    return !!cookies.StaticWebAppsAuthCookie;
};
exports.validateCookie = validateCookie;
const serializeCookie = (cookieName, cookieValue, options) => {
    return cookie_1.default.serialize(cookieName, cookieValue, options);
};
exports.serializeCookie = serializeCookie;
const decodeCookie = (cookieValue) => {
    const cookies = cookie_1.default.parse(cookieValue);
    const decodedValue = Buffer.from(cookies.StaticWebAppsAuthCookie, "base64").toString();
    return JSON.parse(decodedValue);
};
exports.decodeCookie = decodeCookie;
function validateUserConfig(userConfig) {
    let appLocation = undefined;
    let apiLocation = undefined;
    let appArtifactLocation = undefined;
    if (userConfig.appLocation) {
        appLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.appLocation || `.${path_1.default.sep}`));
        if (path_1.default.isAbsolute(userConfig.appLocation)) {
            appLocation = userConfig.appLocation;
        }
    }
    if (userConfig.apiLocation) {
        if (isHttpUrl(userConfig.apiLocation)) {
            apiLocation = userConfig.apiLocation;
        }
        else {
            // use the user's config and construct an absolute path
            apiLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.apiLocation));
        }
        if (path_1.default.isAbsolute(userConfig.apiLocation)) {
            apiLocation = userConfig.apiLocation;
        }
    }
    if (userConfig.appArtifactLocation) {
        appArtifactLocation = path_1.default.normalize(path_1.default.join(process.cwd(), userConfig.appArtifactLocation || `.${path_1.default.sep}`));
        if (path_1.default.isAbsolute(userConfig.appArtifactLocation)) {
            appArtifactLocation = userConfig.appArtifactLocation;
        }
    }
    return {
        appLocation,
        apiLocation,
        appArtifactLocation,
    };
}
const readConfigFile = ({ userConfig } = {}) => {
    const githubActionFolder = path_1.default.resolve(process.cwd(), ".github/workflows/");
    // does the config folder exist?
    if (fs_1.default.existsSync(githubActionFolder) === false) {
        return userConfig && validateUserConfig(userConfig);
    }
    // find the SWA GitHub action file
    // @TODO handle multiple config file
    let githubActionFile = fs_1.default
        .readdirSync(githubActionFolder)
        .filter((file) => file.includes("azure-static-web-apps") && file.endsWith(".yml"))
        .pop();
    // does the config file exist?
    if (!githubActionFile || fs_1.default.existsSync(githubActionFile)) {
        return userConfig && validateUserConfig(userConfig);
    }
    githubActionFile = path_1.default.resolve(githubActionFolder, githubActionFile);
    let githubActionContent = fs_1.default.readFileSync(githubActionFile, "utf8");
    if (typeof githubActionContent !== "string") {
        throw Error("TypeError: GitHub action file content should be a string");
    }
    // MOTE: the YAML library will parse and return properties as sanke_case
    // we will convert those properties to camelCase at the end of the function
    const swaYaml = yaml_1.default.parse(githubActionContent);
    if (!swaYaml) {
        throw Error(`could not parse the SWA workflow file "${githubActionFile}". Make sure it's a valid YAML file.`);
    }
    if (!swaYaml.jobs) {
        throw Error(`missing property 'jobs' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaYaml.jobs.build_and_deploy_job) {
        throw Error(`missing property 'jobs.build_and_deploy_job' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaYaml.jobs.build_and_deploy_job.steps) {
        throw Error(`missing property 'jobs.build_and_deploy_job.steps' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    // hacking this to have an `any` on the type in .find, mainly because a typescript definition for the YAML file is painful...
    const swaBuildConfig = swaYaml.jobs.build_and_deploy_job.steps.find((step) => step.uses && step.uses.includes("static-web-apps-deploy"));
    if (!swaBuildConfig) {
        throw Error(`invalid property 'jobs.build_and_deploy_job.steps[]' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    if (!swaBuildConfig.with) {
        throw Error(`missing property 'jobs.build_and_deploy_job.steps[].with' in the SWA workflow file "${githubActionFile}". Make sure it's a valid SWA workflow file.`);
    }
    // extract the user's config and set defaults
    let { app_build_command = config_1.DEFAULT_CONFIG.appBuildCommand, api_build_command = config_1.DEFAULT_CONFIG.apiBuildCommand, app_location = config_1.DEFAULT_CONFIG.appLocation, app_artifact_location = config_1.DEFAULT_CONFIG.appArtifactLocation, api_location = config_1.DEFAULT_CONFIG.apiLocation, } = swaBuildConfig.with;
    // the following locations (extracted from the config) should be under the user's project folder:
    // - app_location
    // - api_location
    // - app_artifact_location
    app_location = path_1.default.normalize(path_1.default.join(process.cwd(), app_location));
    if (typeof api_location !== "undefined") {
        api_location = path_1.default.normalize(path_1.default.join(process.cwd(), api_location || path_1.default.sep));
    }
    app_artifact_location = path_1.default.normalize(app_artifact_location);
    const detectedRuntimeType = runtimes_1.detectRuntime(app_location);
    if (detectedRuntimeType === runtimes_1.RuntimeType.dotnet) {
        // TODO: work out what runtime is being used for .NET rather than hard-coded
        app_artifact_location = path_1.default.join(app_location, "bin", "Debug", "netstandard2.1", "publish", app_artifact_location);
    }
    else {
        app_artifact_location = path_1.default.join(app_location, app_artifact_location);
    }
    // override SWA config with user's config (if provided):
    // if the user provides different app location, app artifact location or api location, use that information
    if (userConfig) {
        const { apiLocation, appArtifactLocation, appLocation } = validateUserConfig(userConfig);
        app_location = appLocation;
        app_artifact_location = appArtifactLocation;
        api_location = apiLocation;
    }
    // convert variable names to camelCase
    // instead of snake_case
    const config = {
        appBuildCommand: app_build_command,
        apiBuildCommand: api_build_command,
        appLocation: app_location,
        apiLocation: api_location,
        appArtifactLocation: app_artifact_location,
    };
    console.info(`INFO: Found SWA configuration file: ${githubActionFile}`);
    if (process.env.DEBUG) {
        console.info({ config });
    }
    return config;
};
exports.readConfigFile = readConfigFile;
/**
 * Parse process.argv and retrieve a specific flag value.
 * Usage:
 * ```
 * // ./server --port 4242
 * let port = argv<number>('--port');
 * ```
 *
 * @param flag the flag name to retrieve from argv, e.g.: --port
 * @returns {T} the value of the corresponding flag:
 * - if flag is --key=value or --key value, returns value as type `T`.
 * - if flag is --key, return a boolean (true if the flag is present, false if not).
 * - if flag is not present, return null.
 *
 */
function argv(flag) {
    var _a;
    const flags = process.argv;
    for (let index = 0; index < flags.length; index++) {
        const entry = flags[index];
        // ex: --key=value
        if (entry.startsWith("--")) {
            if (entry.includes("=")) {
                // ex: [--key, value]
                const [key, value] = entry.split("=");
                if (flag === key.trim()) {
                    // ex: --key=value --> value
                    // ex: --key=      --> null
                    return (!!value ? value.trim() : null);
                }
            }
            // ex: --key value
            // ex: --key
            else if (flag === entry.trim()) {
                const nextEntry = (_a = flags[index + 1]) === null || _a === void 0 ? void 0 : _a.trim();
                // ex: --key
                if (nextEntry === undefined || (nextEntry === null || nextEntry === void 0 ? void 0 : nextEntry.startsWith("--"))) {
                    return true;
                }
                // ex: --key value
                else if (!!nextEntry) {
                    return nextEntry;
                }
            }
            else {
                // flag wasn't found
                return false;
            }
        }
    }
    return null;
}
exports.argv = argv;
function isAcceptingTcpConnections({ host = "127.0.0.1", port }) {
    return new Promise((resolve) => {
        const socket = net_1.default.createConnection(port, host);
        socket
            .once("error", () => {
            resolve(false);
            socket.end();
        })
            .once("connect", () => {
            resolve(true);
            socket.end();
        });
    });
}
exports.isAcceptingTcpConnections = isAcceptingTcpConnections;
function isHttpUrl(input) {
    try {
        const url = new URL(input);
        return url.protocol.startsWith("http");
    }
    catch {
        return false;
    }
}
exports.isHttpUrl = isHttpUrl;
async function isPortAvailable({ host = "127.0.0.1", port }) {
    return new Promise((resolve, reject) => {
        const server = net_1.default.createServer();
        server
            .once("error", (err) => {
            if (err.code !== "EADDRINUSE") {
                reject(err);
            }
            else {
                resolve(false);
            }
        })
            .once("listening", () => {
            server.close();
            resolve(true);
        })
            .listen(port, host);
    });
}
exports.isPortAvailable = isPortAvailable;
async function validateDevServerConfig(context) {
    let { hostname, port } = parseUrl(context);
    try {
        const appListening = await isAcceptingTcpConnections({ port, host: hostname });
        if (appListening === false) {
            console.info(`INFO: Could not connect to "${context}". Is the server up and running?`);
            process.exit(0);
        }
        else {
            return context;
        }
    }
    catch (err) {
        if (err.message.includes("EACCES")) {
            console.info(`INFO: Port "${port}" cannot be used. You might need elevated or admin privileges. Or, use a valid port: 1024 to 49151.`);
        }
        else {
            console.error(err.message);
        }
        process.exit(0);
    }
}
exports.validateDevServerConfig = validateDevServerConfig;
function parseUrl(url) {
    const { protocol, port, host, hostname } = new URL(url);
    return {
        protocol,
        port: Number(port),
        host,
        hostname,
    };
}
exports.parseUrl = parseUrl;
// @TODO
function computeAppLocationFromArtifactLocation(appArtifactLocation) {
    if (appArtifactLocation) {
        return path_1.default.dirname(appArtifactLocation).split(path_1.default.sep).pop();
    }
    return undefined;
}
exports.computeAppLocationFromArtifactLocation = computeAppLocationFromArtifactLocation;
function getBin(binary) {
    if (binary.indexOf(path_1.default.sep) >= 0) {
        return path_1.default.isAbsolute(binary) ? binary : path_1.default.resolve(binary);
    }
    const binDirOutput = child_process_1.spawnSync(isWindows() ? "npm.cmd" : "npm", ["bin"], { cwd: __dirname });
    const binDirErr = binDirOutput.stderr.toString();
    if (binDirErr) {
        console.error({ binDirErr });
    }
    const binDirOut = binDirOutput.stdout.toString().trim();
    return path_1.default.resolve(binDirOut, isWindows() ? `${binary}.cmd` : binary);
}
exports.getBin = getBin;
function isWindows() {
    var _a;
    return process.platform === "win32" || /^(msys|cygwin)$/.test((_a = process.env) === null || _a === void 0 ? void 0 : _a.OSTYPE);
}
exports.isWindows = isWindows;
function parsePort(port) {
    const portNumber = parseInt(port, 10);
    if (isNaN(portNumber)) {
        console.error(`Port "${port}" is not a number.`);
        process.exit(-1);
    }
    else {
        if (portNumber < 1024 || portNumber > 49151) {
            console.error(`Port "${port}" is out of range. Allowed ports are from 1024 to 49151.`);
            process.exit(-1);
        }
    }
    return portNumber;
}
exports.parsePort = parsePort;
//# sourceMappingURL=utils.js.map